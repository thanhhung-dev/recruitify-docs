# Story 1.4: Search and Filter Job Listings

**Status**: Draft

**Story**

As a job seeker,
I want to search for jobs by keyword and filter them by location and category,
so that I can quickly find opportunities relevant to me.

**Acceptance Criteria**

1. The job listings page includes a text input for keyword searching.
2. The page includes filter controls (e.g., dropdowns) for location and job category.
3. Applying a search or filter updates the list of jobs displayed on the page without a full page reload.
4. The backend API for fetching jobs supports filtering by keyword, location, and category.

**Tasks / Subtasks**

- [ ] **Task 1: Extend Backend JobPosting Repository for Search/Filter (AC: 4)**
  - [ ] Subtask 1.1: Add custom query method `Page<JobPosting> findByStatusAndFilters(String status, String keyword, String location, String category, Pageable pageable)` to `JobPostingRepository`. [Source: architecture/11-backend-architecture.md#data-access-layer-dal]
  - [ ] Subtask 1.2: Implement query using `@Query` annotation with JPQL to support optional keyword search (title or description), location filter, and category filter. [Source: architecture/11-backend-architecture.md#data-access-layer-dal]
  - [ ] Subtask 1.3: Ensure query handles null/empty filter parameters gracefully (returns all results when filter not specified). [Source: Best practice]

- [ ] **Task 2: Update Backend JobService for Search/Filter (AC: 4)**
  - [ ] Subtask 2.1: Update `JobService.getActiveJobs()` method signature to accept filter parameters: `keyword`, `location`, `category`. [Source: architecture/11-backend-architecture.md#service-architecture]
  - [ ] Subtask 2.2: Call the new repository method `findByStatusAndFilters()` instead of `findByStatus()`. [Source: architecture/11-backend-architecture.md#service-architecture]
  - [ ] Subtask 2.3: Maintain existing pagination and sorting behavior (createdAt descending). [Source: Story 1.3 implementation]

- [ ] **Task 3: Update Backend JobController API Endpoint (AC: 4)**
  - [ ] Subtask 3.1: Modify `GET /api/v1/jobs` endpoint in `JobController` to accept additional query parameters: `keyword`, `location`, `category`. [Source: architecture/11-backend-architecture.md#controllerroute-organization]
  - [ ] Subtask 3.2: Pass filter parameters to `JobService.getActiveJobs()` method. [Source: architecture/11-backend-architecture.md#controllerroute-organization]
  - [ ] Subtask 3.3: Ensure endpoint remains public (no authentication required). [Source: Story 1.3 - AC 3]
  - [ ] Subtask 3.4: Update API response to maintain existing pagination format. [Source: Story 1.3 implementation]

- [ ] **Task 4: Update Shared TypeScript Types for Search/Filter (AC: 1, 2)**
  - [ ] Subtask 4.1: Create `JobSearchFilters` interface in `packages/shared-types/job.ts` with fields: `keyword`, `location`, `category`. [Source: architecture/17-coding-standards.md#critical-fullstack-rules]
  - [ ] Subtask 4.2: Ensure all filter fields are optional (can be undefined). [Source: AC 4 - filters are optional]

- [ ] **Task 5: Update Frontend Job Service Layer (AC: 3, 4)**
  - [ ] Subtask 5.1: Update `jobService.getJobs()` function in `apps/web/src/services/jobService.ts` to accept `filters: JobSearchFilters` parameter. [Source: architecture/10-frontend-architecture.md#service-example]
  - [ ] Subtask 5.2: Pass filter parameters as query string to `GET /api/v1/jobs` endpoint. [Source: architecture/10-frontend-architecture.md#api-client-setup]
  - [ ] Subtask 5.3: Maintain existing pagination parameters. [Source: Story 1.3 implementation]

- [ ] **Task 6: Update Frontend Job Store with Search/Filter State (AC: 1, 2, 3)**
  - [ ] Subtask 6.1: Update `useJobsStore.ts` to include `filters` state with type `JobSearchFilters`. [Source: architecture/10-frontend-architecture.md#state-management-patterns]
  - [ ] Subtask 6.2: Create action `setFilters(filters: JobSearchFilters)` to update filter state. [Source: architecture/10-frontend-architecture.md#state-management-patterns]
  - [ ] Subtask 6.3: Update `fetchJobs()` action to pass current filters to `jobService.getJobs()`. [Source: architecture/10-frontend-architecture.md#state-management-patterns]
  - [ ] Subtask 6.4: Create action `clearFilters()` to reset all filters to empty/undefined. [Source: UX best practice]

- [ ] **Task 7: Create Job Search Filter UI Components (AC: 1, 2)**
  - [ ] Subtask 7.1: Create `apps/web/src/features/jobs/JobSearchBar.tsx` component with Ant Design `Input.Search` for keyword search. [Source: architecture/10-frontend-architecture.md#component-organization and architecture/3-tech-stack.md]
  - [ ] Subtask 7.2: Create `apps/web/src/features/jobs/JobFilters.tsx` component with Ant Design `Select` dropdowns for location and category filters. [Source: architecture/10-frontend-architecture.md#component-organization and architecture/3-tech-stack.md]
  - [ ] Subtask 7.3: `JobFilters` should include a "Clear Filters" button. [Source: UX best practice]
  - [ ] Subtask 7.4: Components should use Zustand store's `setFilters()` and `fetchJobs()` actions when filters change. [Source: architecture/10-frontend-architecture.md#state-management-patterns]

- [ ] **Task 8: Integrate Search/Filter UI into Jobs Page (AC: 1, 2, 3)**
  - [ ] Subtask 8.1: Update `apps/web/src/pages/jobs/index.tsx` to include `JobSearchBar` and `JobFilters` components above `JobListingGrid`. [Source: architecture/10-frontend-architecture.md#route-organization]
  - [ ] Subtask 8.2: Implement debounced search for keyword input (300ms delay) to avoid excessive API calls. [Source: Performance best practice]
  - [ ] Subtask 8.3: Reset pagination to page 0 when filters change. [Source: UX best practice]
  - [ ] Subtask 8.4: Ensure job list updates without full page reload (client-side filtering). [Source: AC 3]

- [ ] **Task 9: Populate Filter Dropdown Options (AC: 2)**
  - [ ] Subtask 9.1: Extract unique location values from seed data for location dropdown options. [Source: Story 1.3 seed data]
  - [ ] Subtask 9.2: Define category options based on common job categories (Engineering, Marketing, Sales, Design, Product, etc.). [Source: Story 1.3 data model]
  - [ ] Subtask 9.3: Store filter options as constants in `apps/web/src/constants/jobFilters.ts`. [Source: architecture/12-unified-project-structure.md]

- [ ] **Task 10: Implement Backend Unit Tests for Search/Filter (AC: 4)**
  - [ ] Subtask 10.1: Write unit test for `JobService.getActiveJobs()` with keyword filter to verify it returns matching jobs. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 10.2: Write unit test for `JobService.getActiveJobs()` with location filter. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 10.3: Write unit test for `JobService.getActiveJobs()` with category filter. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 10.4: Write unit test for `JobService.getActiveJobs()` with combined filters (keyword + location + category). [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 10.5: Write unit test to verify null/empty filters return all active jobs. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 10.6: Place tests in `apps/api/src/test/java/com/recruitify/service/JobServiceTest.java`. [Source: architecture/16-testing-strategy.md#test-organization]

- [ ] **Task 11: Implement Backend Integration Tests for Search/Filter API (AC: 4)**
  - [ ] Subtask 11.1: Write integration test for `GET /api/v1/jobs?keyword=engineer` to verify keyword filtering. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 11.2: Write integration test for `GET /api/v1/jobs?location=San%20Francisco` to verify location filtering. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 11.3: Write integration test for `GET /api/v1/jobs?category=Engineering` to verify category filtering. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 11.4: Write integration test for `GET /api/v1/jobs?keyword=senior&location=Remote&category=Engineering` to verify combined filters. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 11.5: Verify pagination still works correctly with filters applied. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 11.6: Place tests in `apps/api/src/test/java/com/recruitify/controller/JobControllerIntegrationTest.java`. [Source: architecture/16-testing-strategy.md#test-organization]

- [ ] **Task 12: Implement Frontend Component Tests for Search/Filter UI (AC: 1, 2)**
  - [ ] Subtask 12.1: Write unit test for `JobSearchBar` to verify it renders search input and calls store action on search. [Source: architecture/16-testing-strategy.md#frontend-component-test-example-jest-rtl]
  - [ ] Subtask 12.2: Write unit test for `JobFilters` to verify it renders location and category dropdowns. [Source: architecture/16-testing-strategy.md#frontend-component-test-example-jest-rtl]
  - [ ] Subtask 12.3: Write unit test for `JobFilters` to verify "Clear Filters" button calls clearFilters action. [Source: architecture/16-testing-strategy.md#frontend-component-test-example-jest-rtl]
  - [ ] Subtask 12.4: Place tests co-located: `JobSearchBar.test.tsx` and `JobFilters.test.tsx`. [Source: architecture/16-testing-strategy.md#test-organization]

- [ ] **Task 13: Implement E2E Tests for Search/Filter Functionality (AC: 1, 2, 3, 4)**
  - [ ] Subtask 13.1: Create Playwright E2E test to navigate to `/jobs` page and verify search bar and filter dropdowns are visible. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
  - [ ] Subtask 13.2: Test entering a keyword in search bar and verify filtered results display without page reload. [Source: AC 1, 3]
  - [ ] Subtask 13.3: Test selecting a location filter and verify filtered results display. [Source: AC 2, 3]
  - [ ] Subtask 13.4: Test selecting a category filter and verify filtered results display. [Source: AC 2, 3]
  - [ ] Subtask 13.5: Test applying multiple filters simultaneously and verify combined filtering works. [Source: AC 3, 4]
  - [ ] Subtask 13.6: Test "Clear Filters" button and verify all jobs display again. [Source: UX best practice]
  - [ ] Subtask 13.7: Place tests in `e2e/jobs-search-filter.spec.ts`. [Source: architecture/16-testing-strategy.md#test-organization]

**Dev Notes**

**Previous Story Insights**: Story 1.3 (View Job Listings) established the foundational job listing functionality including:
- `JobPosting` entity with fields: id, recruiterId, companyId, title, description, location, category, salaryMin, salaryMax, salaryCurrency, status, createdAt, updatedAt
- `JobPostingRepository` with `findByStatus()` method for fetching active jobs
- `JobService` with `getActiveJobs(Pageable pageable)` method supporting pagination
- `GET /api/v1/jobs` public endpoint with pagination (page, size params)
- Frontend job listing components: `JobListingCard`, `JobListingGrid`
- `useJobsStore` Zustand store managing jobs state
- `/jobs` page displaying paginated job listings

This story extends that foundation by adding search and filter capabilities on top of the existing pagination.

**Important Architectural Constraint**: Story 1.3 notes that the `JobPosting` data model was inferred and not fully defined in architecture/4-data-models.md. The architecture mentions "A User with the RECRUITER role has many JobPostings" but does not provide complete field definitions. For this story, we will rely on the data model established in Story 1.3.

**Data Models**:

*   **JobPosting Model (from Story 1.3)**:
    *   `id`: `string` (UUID) - Primary key
    *   `recruiterId`: `string` (UUID, FK to User)
    *   `companyId`: `string` (UUID, FK to Company)
    *   `title`: `string` - Job title (searchable field)
    *   `description`: `string` - Full job description (searchable field)
    *   `location`: `string` - Job location (filterable field)
    *   `category`: `string` - Job category/type (filterable field)
    *   `salaryMin`: `number`
    *   `salaryMax`: `number`
    *   `salaryCurrency`: `string`
    *   `status`: `'ACTIVE' | 'INACTIVE' | 'CLOSED'`
    *   `createdAt`: `Date`
    *   `updatedAt`: `Date`
    *   [Source: Story 1.3 Dev Notes]

**TypeScript Interfaces**:

```typescript
// In packages/shared-types/job.ts (extends Story 1.3)

export interface JobSearchFilters {
  keyword?: string;      // Searches title and description
  location?: string;     // Exact match or contains
  category?: string;     // Exact match
}

// JobListing interface already exists from Story 1.3
// PaginatedResponse<T> interface already exists from Story 1.3
```

**API Specifications**:

*   Server URL: `/api/v1`. [Source: architecture/5-api-specification.md#rest-api-specification-openapi-30]
*   **GET /api/v1/jobs**: Updated to support search and filter parameters
    *   **Query Params**:
        *   `page` (number, default: 0) - Pagination page number
        *   `size` (number, default: 20) - Page size
        *   `keyword` (string, optional) - Searches job title and description (case-insensitive, partial match)
        *   `location` (string, optional) - Filters by location (case-insensitive, contains)
        *   `category` (string, optional) - Filters by category (case-insensitive, exact match)
    *   **Response**: `PaginatedResponse<JobListing>` (200 OK)
    *   **Authentication**: Public endpoint (no auth required) [Source: Story 1.3 - AC 3]
    *   Example: `GET /api/v1/jobs?keyword=engineer&location=San%20Francisco&category=Engineering&page=0&size=20`

**Database Query Strategy**:

For search and filter functionality, the backend will use JPQL (Java Persistence Query Language) with dynamic query building:

```java
// Example JPQL query in JobPostingRepository
@Query("SELECT jp FROM JobPosting jp WHERE jp.status = :status " +
       "AND (:keyword IS NULL OR LOWER(jp.title) LIKE LOWER(CONCAT('%', :keyword, '%')) " +
       "OR LOWER(jp.description) LIKE LOWER(CONCAT('%', :keyword, '%'))) " +
       "AND (:location IS NULL OR LOWER(jp.location) LIKE LOWER(CONCAT('%', :location, '%'))) " +
       "AND (:category IS NULL OR LOWER(jp.category) = LOWER(:category))")
Page<JobPosting> findByStatusAndFilters(
    @Param("status") String status,
    @Param("keyword") String keyword,
    @Param("location") String location,
    @Param("category") String category,
    Pageable pageable
);
```

[Source: architecture/11-backend-architecture.md#data-access-layer-dal patterns]

**Component Specifications**:

*   **JobSearchBar**: A search input component using Ant Design's `Input.Search` component. Should have placeholder text "Search jobs by keyword...". On search, calls `useJobsStore.setFilters()` and `useJobsStore.fetchJobs()`. [Source: architecture/10-frontend-architecture.md#component-organization and architecture/3-tech-stack.md]

*   **JobFilters**: A filter panel component with two Ant Design `Select` dropdowns for location and category, plus a "Clear Filters" button. Should use a horizontal layout (Row/Col) for responsive design. [Source: architecture/10-frontend-architecture.md#component-organization and architecture/3-tech-stack.md]

**File Locations**:

*   **Backend**:
    *   Repository: `apps/api/src/main/java/com/recruitify/repository/JobPostingRepository.java` (modify existing)
    *   Service: `apps/api/src/main/java/com/recruitify/service/JobService.java` (modify existing)
    *   Controller: `apps/api/src/main/java/com/recruitify/controller/JobController.java` (modify existing)
    *   Tests: `apps/api/src/test/java/com/recruitify/service/JobServiceTest.java`, `apps/api/src/test/java/com/recruitify/controller/JobControllerIntegrationTest.java` (modify existing)

*   **Frontend**:
    *   Shared Types: `packages/shared-types/job.ts` (modify existing)
    *   Service: `apps/web/src/services/jobService.ts` (modify existing)
    *   Store: `apps/web/src/stores/useJobsStore.ts` (modify existing)
    *   New Components: `apps/web/src/features/jobs/JobSearchBar.tsx`, `apps/web/src/features/jobs/JobFilters.tsx`
    *   Constants: `apps/web/src/constants/jobFilters.ts` (new)
    *   Page: `apps/web/src/pages/jobs/index.tsx` (modify existing)
    *   Tests: `apps/web/src/features/jobs/JobSearchBar.test.tsx`, `apps/web/src/features/jobs/JobFilters.test.tsx`

*   **E2E**: `e2e/jobs-search-filter.spec.ts` (new)

[Source: architecture/12-unified-project-structure.md#project-directory-structure]

**Filter Options**:

*   **Location Options**: Should be derived from the seed data created in Story 1.3. Alternatively, create a static list of common locations for MVP: ["Remote", "San Francisco, CA", "New York, NY", "Austin, TX", "Seattle, WA", "Boston, MA", "Other"]

*   **Category Options**: Based on common job categories: ["Engineering", "Product", "Design", "Marketing", "Sales", "Customer Success", "Operations", "Data", "Other"]

[Source: Inferred from Story 1.3 seed data requirements]

**Technical Constraints**:

*   **Performance**: Add database indexes on `title`, `location`, and `category` columns in `job_postings` table for faster search/filter queries. Target response time < 100ms even with filters applied. [Source: architecture/15-security-and-performance.md#backend-performance]

*   **Search Behavior**: Keyword search should be case-insensitive and support partial matching. Search should check both `title` and `description` fields. [Source: Common search UX pattern]

*   **Filter Behavior**: Location filter should use case-insensitive "contains" matching (e.g., "san francisco" matches "San Francisco, CA"). Category filter should use exact matching (case-insensitive). All filters are optional and can be combined. [Source: UX best practice]

*   **Debouncing**: Frontend keyword search should implement debouncing (300ms delay) to avoid excessive API calls while user is typing. [Source: Performance best practice]

*   **State Reset**: When filters change, pagination should reset to page 0 to avoid confusion (displaying page 3 of filtered results that only have 1 page). [Source: UX best practice]

*   **Service Layer Pattern**: Frontend components must NEVER make direct HTTP requests; always use `jobService`. [Source: architecture/17-coding-standards.md#critical-fullstack-rules]

*   **Shared Types**: All types shared between frontend and backend MUST be defined in `packages/shared-types`. [Source: architecture/17-coding-standards.md#critical-fullstack-rules]

**Naming Conventions**:

*   React components: `PascalCase` (e.g., `JobSearchBar.tsx`, `JobFilters.tsx`) [Source: architecture/17-coding-standards.md#naming-conventions]
*   React hooks: `useCamelCase` (e.g., `useJobsStore.ts`) [Source: architecture/17-coding-standards.md#naming-conventions]
*   Java classes: `PascalCase` (e.g., `JobController.java`) [Source: architecture/17-coding-standards.md#naming-conventions]
*   API endpoints: `kebab-case` (e.g., `/api/v1/jobs`) [Source: architecture/17-coding-standards.md#naming-conventions]
*   Database tables: `snake_case` (e.g., `job_postings`) [Source: architecture/17-coding-standards.md#naming-conventions]
*   Database columns: `snake_case` (e.g., `recruiter_id`, `created_at`) [Source: architecture/17-coding-standards.md#naming-conventions]

**Testing**

**Unit Tests:**
*   **Backend**: Use JUnit 5 & Mockito. Tests in `apps/api/src/test/java` mirroring main source structure. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]
*   **Frontend**: Use Jest & React Testing Library. Tests co-located with components. [Source: architecture/16-testing-strategy.md#test-organization]

**Integration Tests:**
*   Backend controller-service-repository tests to verify full API request/response cycle with search/filter parameters. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]

**E2E Tests:**
*   Use Playwright to test user journey of searching and filtering jobs, verifying results update without page reload. [Source: architecture/16-testing-strategy.md#the-testing-pyramid]

**Test Coverage Requirements:**
*   Test all filter combinations: keyword only, location only, category only, and all combined
*   Test edge cases: empty search, no results, clearing filters
*   Test pagination behavior with filters applied
*   Tests should be placed according to the testing strategy: backend tests in `src/test/java`, frontend tests co-located, E2E tests in `e2e/` directory. [Source: architecture/16-testing-strategy.md#test-organization]

**Change Log**

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-11-06 | 1.0 | Initial draft based on Epic 1, Story 1.4 | Bob (SM) |

**Dev Agent Record**

**Agent Model Used**
{{agent_model_name_version}}

**Debug Log References**

**Completion Notes List**

**File List**

**QA Results**
